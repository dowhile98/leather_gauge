/**
 *
 */

//-------------------------------------------------------------------------------
// includes
//-------------------------------------------------------------------------------
#include "lgc.h"
#include "lgc_interface_printer.h"
#include "os_port.h"
#include "lgc_module_input.h"

//-------------------------------------------------------------------------------
// defines
//-------------------------------------------------------------------------------
#ifndef LGC_SENSOR_NUMBER
#define LGC_SENSOR_NUMBER 11
#endif
typedef struct
{
	/*state machine*/
	uint8_t state;

	uint16_t sensor[LGC_SENSOR_NUMBER];

} lgc_t;

typedef enum
{
	LGC_STOP = 0,
	LGC_RUNNING,
	LGC_FAIL,

} LGC_State_t;
//-------------------------------------------------------------------------------
// global variables
//-------------------------------------------------------------------------------
lgc_t data;
static OsSemaphore encoder_flag;
static OsMutex mutex;
//-------------------------------------------------------------------------------
// private function prototype
//-------------------------------------------------------------------------------
static void lgc_encoder_callback(void);

static uint8_t lgc_get_state(void);

static uint8_t lgc_set_state(uint8_t state);
//-------------------------------------------------------------------------------
// task definition
//-------------------------------------------------------------------------------
void lgc_main_task_entry(void *param)
{
	error_t err = NO_ERROR;

	/*create semaphore*/
	osCreateSemaphore(&encoder_flag, 0);
	/*Mutex*/
	osCreateMutex(&mutex);
	/*encoder init*/
	lgc_module_encoder_init(lgc_encoder_callback);

	for (;;)
	{
		// UML
		switch (lgc_get_state())
		{
		case LGC_STOP:
		{
			//verify start condition
			
			break;
		}
		case LGC_RUNNING:
		{
			//verify stop condition

			break;
		}
		case LGC_FAIL:
		{
			//verify reset condition
			break;
		}
		}
		/*state machine*/

		//    	for(uint8_t i = 0; i<LGC_SENSOR_NUMBER; i++)
		//    	{
		//    		err = lgc_modbus_read_holding_regs(i +1 , 45, &data.sensor[i], 1);
		//
		//    		if( err!= NO_ERROR)
		//    		{
		//    			osDelayTask(50);
		//    		}
		//    	}
		//        /* code */
		//        osDelayTask(1000);
	}
}
//-------------------------------------------------------------------------------
// callbacks
//-------------------------------------------------------------------------------
static void lgc_encoder_callback(void)
{
	// set flag
	osReleaseSemaphore(&encoder_flag);
}

static uint8_t lgc_get_state(void)
{
	return data.state;
}

static uint8_t lgc_set_state(uint8_t state)
{
	/*Mutex protection*/
	osAcquireMutex(&mutex);
	/*set state*/
	data.state = state;
	/*return state*/
	osReleaseMutex(&mutex);

	return data.state;
}
//-------------------------------------------------------------------------------
// private function definition
//-------------------------------------------------------------------------------
