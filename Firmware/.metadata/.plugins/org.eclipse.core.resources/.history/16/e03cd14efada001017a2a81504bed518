/*
 * lg_module_eeprom.c
 *
 *  Created on: Dec 16, 2025
 *      Author: tecna-smart-lab
 */

/* ============================================================================
 * includes
 * ========================================================================= */
#include "lg_module_eeprom.h"
#include "stm32g0xx_hal.h"
#include "stm32g0xx_hal_flash.h"
/* ============================================================================
 * defines
 * ========================================================================= */
// El STM32G030C8 tiene 64KB de Flash.
// Dirección Base: 0x08000000
// Última página (Página 31): 0x0800F800 - 0x0800FFFF (2KB)
#define EEPROM_START_ADDRESS ((uint32_t)0x0800F800)
#define EEPROM_PAGE_SIZE ((uint16_t)0x0800) // 2KB (2048 bytes)
/* ============================================================================
 * global variables
 * ========================================================================= */
static LG_CONF_TypeDef_t conf;

static uint64_t ram_page_buffer[EEPROM_PAGE_SIZE / 8];
/* ============================================================================
 * function definition
 * ========================================================================= */
/**
 * @brief  Inicializa el módulo (verifica alineación o integridad básica)
 * @retval 0: Éxito, 1: Error
 */
uint8_t lg_module_eeprom_init(void)
{
    // En esta implementación simple, no hay hardware externo que inicializar.
    // Podrías agregar aquí una verificación de "Magic Number" si quisieras
    // saber si la memoria está virgen o ya tiene datos.
    return 0;
}

/**
 * @brief  Lee datos de la Flash emulada.
 * @param  addr: Offset relativo (0 a 2047) desde el inicio de la página emulada.
 * @param  buffer: Puntero donde guardar los datos.
 * @param  size: Cantidad de bytes a leer.
 * @retval 0: Éxito, 1: Error (fuera de rango)
 */
uint8_t lg_module_eeprom_read(uint32_t addr, uint8_t *buffer, uint16_t size)
{
    // 1. Validación de límites
    if ((addr + size) > EEPROM_PAGE_SIZE)
    {
        return 1; // Error: Intento de leer fuera de la página reservada
    }

    // 2. Lectura directa (La flash es memory mapped)
    // Calculamos la dirección física absoluta
    uint32_t absolute_addr = EEPROM_START_ADDRESS + addr;

    // 3. Copiamos los datos
    memcpy(buffer, (void *)absolute_addr, size);

    return 0; // Éxito
}

/**
 * @brief  Escribe datos en la Flash emulada (Read-Modify-Write).
 * @param  addr: Offset relativo (0 a 2047).
 * @param  buffer: Datos a escribir.
 * @param  size: Cantidad de bytes.
 * @retval 0: Éxito, Other: Error HAL
 */
uint8_t lg_module_eeprom_write(uint32_t addr, uint8_t *buffer, uint16_t size)
{
    HAL_StatusTypeDef status;
    uint32_t page_error = 0;
    FLASH_EraseInitTypeDef erase_init;

    // 1. Validación de límites
    if ((addr + size) > EEPROM_PAGE_SIZE)
    {
        return 1; // Error: Fuera de rango
    }

    // 2. Copiar TODA la página actual de Flash a RAM (Backup)
    // Usamos punteros para asegurar el copiado correcto al array de uint64_t
    memcpy(ram_page_buffer, (void *)EEPROM_START_ADDRESS, EEPROM_PAGE_SIZE);

    // 3. Modificar solo los bytes necesarios en el buffer de RAM
    // Casteamos a uint8_t* para movernos byte a byte en el buffer
    uint8_t *byte_ptr = (uint8_t *)ram_page_buffer;
    memcpy(&byte_ptr[addr], buffer, size);

    // 4. Desbloquear la Flash para escritura
    HAL_FLASH_Unlock();

    // 5. Borrar la página de Flash
    erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
    erase_init.Banks = FLASH_BANK_1;
    erase_init.Page = 31; // Página 31 es la última en 64KB (0x0800F800)
    erase_init.NbPages = 1;

    status = HAL_FLASHEx_Erase(&erase_init, &page_error);
    if (status != HAL_OK)
    {
        HAL_FLASH_Lock();
        return 2; // Error al borrar
    }

    // 6. Escribir el buffer RAM actualizado de vuelta a la Flash
    // El STM32G0 requiere escritura de DoubleWord (64 bits)
    for (uint32_t i = 0; i < (EEPROM_PAGE_SIZE / 8); i++)
    {
        // Calculamos la dirección absoluta de destino
        uint32_t dest_addr = EEPROM_START_ADDRESS + (i * 8);

        // Obtenemos el dato de 64 bits del buffer
        uint64_t data = ram_page_buffer[i];

        status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, dest_addr, data);
        if (status != HAL_OK)
        {
            HAL_FLASH_Lock();
            return 3; // Error al escribir
        }
    }

    // 7. Bloquear la Flash
    HAL_FLASH_Lock();

    return 0; // Éxito
}